//https://docs.npmjs.com/getting-started/creating-node-modules
//https://googlechrome.github.io/samples/classes-es6/
class transaction_analysis{
	constructor(granularity, warning_threshold, critical_threshold){
		this.transactions = [];
		this.num_transactions = 0;
		this.start_time = Date.now();
		this.end_time = Date.now();
		this.granularity = granularity;
		this.numBuckets = 12;
		this.warning_threshold = warning_threshold;
		this.critical_threshold = critical_threshold;
		//Colour Defaults:
		this.okColour = "#78B24A";
		this.warningColour = "#E0C135";
		this.criticalColour = "#DD0000";
		this.noDataColour = "#5EBFC6";
		//----------------
		this.data_item;
		this.current_transaction;
	}
	

	//Method to set all the colours for OK / Warning/ Critical / NoData
	set_colours(okColour, warningColour, criticalColour, noDataColour){
		this.okColour = okColour;
		this.warningColour = warningColour;
		this.criticalColour = criticalColour;
		this.noDataColour = noDataColour;
	}


	setData(data){
		var temp_bucket;
		var bucket;
		var bucket_start_time_seconds;
		var bucket_end_time_seconds;
		var bucket_index = 0;
		var start_time_in_seconds;
		var i = 0;
		var fields = [];
		var data_item;
		var current_transaction;
		var k;
		var oMoment = require('moment');
		var date_first_row;
		var date_last_row;
		var date_temp;
		var oMoment = require('moment');
		var SplunkVisUtils = require('api/SplunkVisualizationUtils');
		var vizUtils = require('api/SplunkVisualizationUtils');
		const { transaction_analysis, transaction, time_bucket } = require('jds_transaction_analysis');
		//------------------------------  Get data row field indexes ----------------------------------------------------------------------
		for (i=0; i<data.fields.length; i++){
			fields[data.fields[i].name.toLowerCase()]  = i;
		}

		// Set up the Start and End dates based on data supplied. This will determine how much time each bucket has, as  num_buckets is configurable
		date_first_row = data.rows[0][fields["_time"]];
		date_first_row  = oMoment(date_first_row);
		date_last_row = data.rows[data.rows.length-1][fields["_time"]];
		date_last_row = oMoment(date_last_row); //, 'DD/MM/YYYY HH:mm:ss A'
		//Set earliest time as start time, and latest time as end time
		if (date_first_row > date_last_row) { 
			this.start_time = SplunkVisUtils.parseTimestamp(date_last_row);
			this.end_time = SplunkVisUtils.parseTimestamp(date_first_row);
		}else{
			this.start_time = SplunkVisUtils.parseTimestamp(date_first_row);
			this.end_time = SplunkVisUtils.parseTimestamp(date_last_row);
		}
		var currentTime = this.start_time.getTime();
		var localOffset = (-1) * this.start_time.getTimezoneOffset() * 60000;
		var start_time_in_seconds = Math.round(new Date(currentTime + localOffset).getTime() / 1000);
		var start_time_in_seconds_utc = this.start_time.getTime()/1000;
		// Timezone won't affect the number of buckets
		this.num_buckets = Math.ceil(((this.end_time.getTime() / 1000)  - (this.start_time.getTime() / 1000) ) / (this.granularity*60));
		//---------------- End set start / end time from data object ----------------------------


		// Get the current transation, or create it if it doesn't yet exist
		for (i=0; i<data.rows.length; i++){
			data_item = data.rows[i];
			//------------------------------  Create or Locate Transaction Objects ----------------------------------------------------------------------
			if(typeof this.transactions[vizUtils.escapeHtml(data_item[fields["transaction_name"]])] === 'undefined') {
				// does not exist
				this.transactions[vizUtils.escapeHtml(data_item[fields["transaction_name"]])] = new transaction(vizUtils.escapeHtml(data_item[fields["transaction_name"]]));
				this.num_transactions++;
				current_transaction = this.transactions[vizUtils.escapeHtml(data_item[fields["transaction_name"]])];
				current_transaction.num_buckets = this.num_buckets;
				// Create Time Buckets for this transaction
				for(k=0;k<current_transaction.num_buckets;k++){
					//Set up the time bucket
					bucket_start_time_seconds = start_time_in_seconds + (k *  this.granularity * 60);
					bucket_end_time_seconds = start_time_in_seconds + ((1+k) * this.granularity * 60);
					temp_bucket = new time_bucket();
					temp_bucket.set_colours(this.okColour, this.warningColour, this.criticalColour, this.noDataColour);
					temp_bucket.warning_threshold = data_item[fields["warning_threshold"]] || this.warning_threshold;
					temp_bucket.critical_threshold = data_item[fields["critical_threshold"]] || this.critical_threshold;
					temp_bucket.set_start_time(bucket_start_time_seconds);
					temp_bucket.set_end_time(bucket_end_time_seconds);
					//Add to Transaction's bucket array
					current_transaction.buckets.push(temp_bucket);
				}
			} else {
				// does exist
			}
			//------------------------------  Fill in details for Bucket Objects ----------------------------------------------------------------------
			current_transaction = this.transactions[vizUtils.escapeHtml(data_item[fields["transaction_name"]])];		
			// Find the correct bucket to put the transaction details into:
			// Index = Math.ceiling(   (time - start_time) / granularity   ) 
			bucket_start_time_seconds = oMoment(data_item[fields["_time"]]).toDate().getTime()/1000; 
			bucket_index = Math.ceil(   (bucket_start_time_seconds - (start_time_in_seconds_utc-1)) / (60*this.granularity)) -1;
			current_transaction.buckets[bucket_index].add_transaction(data_item, fields);
		}	
	}

	getHTML(){
		var transaction_counter = 0;
		var bucket_counter = 0;
		var html = '<table class="transaction_analysis">';
		var transaction;
		var oMoment = require('moment');
		var transaction_names = Object.keys(this.transactions);
		for(transaction_counter=0; transaction_counter < transaction_names.length ; transaction_counter++){
			transaction = this.transactions[transaction_names[transaction_counter]];
			
			// Print out the header row of the table
			if(transaction_counter==0){
				html += '<tr><td>&nbsp;</td>';
				for(bucket_counter=0; bucket_counter < this.num_buckets -1; bucket_counter++){
					html += '<td class="time">' + oMoment(transaction.buckets[bucket_counter].start_time).format("h:mm A") + '</td>';
				}
				html+= '</tr>';
			}
			//---------------------------------------
			html += '<tr><tr><td class="transaction_name">' + transaction.name + '</td>';
			for(bucket_counter=0; bucket_counter < this.num_buckets -1; bucket_counter++){
				html += transaction.buckets[bucket_counter].getHTML();
			}
			html += '</tr>';
		} // loop transaction_counter
		html += '</table>';
		return html;
	}
}

/* transaction class
	This class defines a row in the transaction analysis graph.
	It will house the time buckets, transaction name etc.
	There will be multiple instances, but one per transaction name
*/
class transaction{

	constructor(tname){
		this.name = tname;		// the Transaction Name
		this.num_passed = 0;		// The number of passed transactions
		this.num_failed = 0;		// The number of failed transactions
		this.total = 0;			// the Total number of transactions
		this.buckets = [];	// The timebuckets
	}
}

/* timeBucket class
	This class is a collection of cells that will become the red/yellow/green/blue boxes in the analysis graph
*/
class  time_bucket {
	
	constructor(){
		this.start_time;
		this.end_time;
		this.sum_response_time = 0.0;
		this.average_response_time = 0.0;
		this.num_passed = 0;
		this.num_failed = 0;
		this.total = 0;
		this.errorpc = 0.0;
		this.warning_threshold = 8;
		this.critical_threshold = 12;
		//Colour Defaults:
		this.okColour = "#78B24A";
		this.warningColour = "#E0C135";
		this.criticalColour = "#DD0000";
		this.noDataColour = "#5EBFC6";
	}
	

	set_colours(okColour, warningColour, criticalColour, noDataColour){
		this.okColour =okColour;
		this.warningColour = warningColour;
		this.criticalColour = criticalColour;
		this.noDataColour = noDataColour;
	}
	set_start_time(start){ 
		this.start_time = new Date(1970, 0, 1); // Epoch
		this.start_time.setSeconds(start);
    }
	
	set_end_time (end){
		this.end_time = new Date(1970, 0, 1); // Epoch
		this.end_time.setSeconds(end);
    };
	
	add_transaction(result_row,fields){
		// Add the passed, failed, update percentages etc
		if (result_row[fields["result"]].toLowerCase()=="pass"){
			this.num_passed++;
			this.sum_response_time += parseFloat(result_row[fields["response_time"]]);
			this.average_response_time = Math.round(this.sum_response_time/ this.num_passed,2);
		} 
		if (result_row[fields["result"]].toLowerCase()=="fail") this.num_failed++;
		this.total++;
		this.errorpc = +((this.num_failed / this.total).toFixed(2));
	}
	
	getHTML(){
		var css_class= '';
		var html = '';
		var colour = "";
		// ---- Errors ----
		if (this.errorpc >= 0) css_class = 'error_0';
		if (this.errorpc >= .10) css_class =  'error_10';
		if (this.errorpc >= .30) css_class =  'error_30';
		if (this.errorpc >= .50) css_class =  'error_50';
		if (this.errorpc >= .70) css_class =  'error_70';
		if (this.errorpc >= .90) css_class =  'error_90';
		if (this.num_passed==0){
		// ---- No Data----
			css_class += ' nodata';
			colour = this.noDataColour;
		}else{
			// ---- Response Time ----
			if (this.average_response_time >= this.critical_threshold){ css_class += ' critical'; colour = this.criticalColour;}
			if (this.average_response_time < this.critical_threshold && this.average_response_time >= this.warning_threshold) { css_class += ' warning'; colour = this.warningColour;}
			if (this.average_response_time < this.warning_threshold) {css_class += ' ok'; colour = this.okColour;}
		}
		html = '<td class="jds_ta_clickable ' + css_class + '" style="background-color: ' + colour + '!IMPORTANT" start_time="' + (this.start_time.getTime()/1000) + '" end_time="'+ (this.end_time.getTime()/1000) + '"><img src="/static/app/transaction_analysis_vis/images/blank.gif" style="width:32px; height: 17px;" width="32" height="17" title="Total Passed: '+ this.num_passed + "\nTotal Failed: " + this.num_failed + "\nTotal Transactions: " + this.total + '" /></td>';
				
		return html;
	}
}



module.exports = { transaction_analysis, transaction, time_bucket}
