{
  "_args": [
    [
      {
        "raw": "classes",
        "scope": null,
        "escapedName": "classes",
        "name": "classes",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/opt/splunk/etc/apps/transaction_analysis_vis/appserver/static/visualizations/transaction_analysis"
    ]
  ],
  "_from": "classes@latest",
  "_id": "classes@0.3.0",
  "_inCache": true,
  "_location": "/classes",
  "_npmUser": {
    "name": "k",
    "email": "kbjr14@gmail.com"
  },
  "_npmVersion": "1.1.69",
  "_phantomChildren": {},
  "_requested": {
    "raw": "classes",
    "scope": null,
    "escapedName": "classes",
    "name": "classes",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/classes/-/classes-0.3.0.tgz",
  "_shasum": "16e6033749ead443b1c54520341291708d9b678f",
  "_shrinkwrap": null,
  "_spec": "classes",
  "_where": "/opt/splunk/etc/apps/transaction_analysis_vis/appserver/static/visualizations/transaction_analysis",
  "author": {
    "name": "James Brumond",
    "email": "james@jbrumond.me",
    "url": "http://jbrumond.me"
  },
  "bugs": {
    "url": "https://github.com/kbjr/class.js/issues"
  },
  "dependencies": {},
  "description": "A classical inheritence model with support for mixins",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "16e6033749ead443b1c54520341291708d9b678f",
    "tarball": "https://registry.npmjs.org/classes/-/classes-0.3.0.tgz"
  },
  "engines": {
    "node": "*"
  },
  "homepage": "https://github.com/kbjr/class.js#readme",
  "main": "classes.js",
  "maintainers": [
    {
      "name": "k",
      "email": "kbjr14@gmail.com"
    }
  ],
  "name": "classes",
  "optionalDependencies": {},
  "readme": "# class.js\n\nSimple but powerful classical inheritence for JavaScript.\n\n## Node.js install\n\n```bash\n$ npm install classes\n```\n\nIf using Node.js, you may want to make classes global using code such as this near the beginning of your application.\n\n```javascript\nglobal.Class = require('classes').Class;\n```\n\n## Basic Example\n\n```javascript\n// If using Node.js, the module needs to be required (unless global as shown above)\nvar Class = require('classes').Class;\n\n// A general animal class\nClass('Animal', {\n    \n    construct: function(name) {\n        this.name = name;\n    },\n    \n    makeNoise: function(noise) {\n        alert(noise);\n    }\n    \n});\n\n// Create a class for making people\nClass('Person').Extends('Animal', {\n    \n    speak: function(sayWhat) {\n        this.makeNoise(this.name + ' says: \"' + sayWhat + '\"');\n    }\n    \n});\n\n// Create an instance of our person class\nvar james = new Person('James');\n\n// And make them talk\njames.speak('Hello, World');\n```\n\n## Extending Classes\n\nThere are multiple allowed syntaxes for extending classes, which you can choose at your preference.\n\n```javascript\n// Create a base class first\nClass('A', {\n    ...\n});\n\n// Using the Extends() syntax\nClass('B').Extends(A, {\n    ...\n});\n\n// Using the complex Class() syntax\nClass('B', A, {\n    ...\n});\n\n// Using the extend() syntax\nA.extend('B', {\n    ...\n});\n```\n\nAlso note, that when using the `Extends()` syntax or the complex `Class()` syntax, both a parent class _variable_ (`A`) or _string_ (`'A'`) is allowed, but if you use the string syntax, the parent class must exist on the namespace object.\n\n## Using Super\n\nYou can call the super of any method at any time. This is done using the `parent` method on your class methods.\n\n```javascript\nClass('A').Extends(SomeOtherClass, {\n    \n    method: function() {\n        // Call the method's super\n        this.method.parent(this);\n    },\n    \n    methodWithArgs: function(arg1) {\n        // Call this method's super, passing the argument along\n        this.methodWithArgs.parent(this, arg1);\n    },\n\n    anotherMethod: function() {\n        // Call the super, but pass in the arguments object\n        this.anotherMethod.parentApply(this, arguments);\n    },\n    \n});\n```\n\n## Creating Anonymous Classes\n\nUsing class.js, classes don't have to be assigned a name. You can also tell the `Class()` function to simply return the constructed class function by passing a falsey first param (like `Class(null)`) or by simply not giving one as seen below.\n\n```javascript\n// This class will automatically be declared at global.Animal\nClass('Animal', {\n    ...\n});\n\n// This class will not be declared globally, but instead just returned\nvar Snake = Class().Extends(Animal, {\n    ...\n});\n\n// A slightly cleaner syntax\nvar Snake = Animal.extend({\n    // ...\n});\n```\n\n## Defining Classes in Non-Global Scope\n\nTo define a class, but assign it somewhere other that the global object, you pass in a two key array as the class name. The first value is the object to define the class on, and the second is the class name.\n\n```javascript\n// This is where we will put the class\nvar someObject = { };\n\n// Now define the class\nClass([someObject, 'Animal'], {\n    ...\n});\n\n// And use the class\nvar animal = new someObject.Animal();\n```\n\nThis is equivilent to the following:\n\n```javascript\nsomeObject.Animal = Class({\n\t...\n});\n```\n\n## Using Mixins\n\nAs of version 0.2.0, mixins are supported. It should be noted that mixins are __not__ the same as sub-class inheritence. A single class can implement both a parent class as well as mixins. Mixins are defined using the `Class.mixin` method.\n\n```javascript\nClass.mixin('CanFoo', {\n\t\n\tfoo: function() {\n\t\talert('Foo!');\n\t}\n\t\n});\n```\n\nOnce created, a mixin is used with the `uses` method when defining a class.\n\n```javascript\nClass('Thing').Uses([ 'CanFoo' ], {\n\t\n\t// ...\n\t\n});\n\nvar thing = new Thing();\nthing.foo();\n```\n\nMixins are different from inheritence in the sense that they do no add to the inheritence chain, they simply extend the current class with certain functionality. You cannot use `instanceof` to determine mixin inheritence because classes are not instances of mixins; In fact, there is no such thing as an _instance_ of a mixin, they are just objects.\n\n## Using Namespaces\n\nBefore version 0.2.0, all new classes and mixins were defined, by default, on the global object, and if you wanted to define one elsewhere, you would have to use either anonymous classes or the array syntax (eg. `Class([exports, 'Foo'], ...)`). There is now a new way of defining namespaced classes that should prove useful, especially in the case of Node.js.\n\n```javascript\nvar Class = require('classes').Class;\nClass.namespace(exports);\n\nClass('Foo', {\n\t\n\t// ...\n\t\n});\n\nvar foo = new exports.Foo();\n```\n\nThe `Class.namespace()` function sets the default namespace, allowing shorter, more readable class declarations. Simply call `Class.namespace(exports)` at the top of your modules and your classes will automatically be defined in the correct space.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/kbjr/class.js.git"
  },
  "version": "0.3.0"
}
